# react-animation-workshop
Animasjonsworkshop for React-faggruppen 2019!

# Introduksjon (Bendik oversetter)
Velkommen til animasjonsworkshop! I denne workshopen skal du f친 leke deg med et relativt nytt animasjonsrammeverk: **Framer Motion**! Versjon 1 av Framer Motion ble lansert i juni i 친r, og er etterf칮lgeren til *Pose*, for de som er kjent med det. For en kort intro til Framer Motion kan du lese [denne artikkelen](https://medium.com/better-programming/smooth-animations-with-react-and-framer-motion-c272b6f22f67).

Selve dokumentasjonen til Framer Motion API'et [finner du her](https://www.framer.com/api/motion/?source=post_page-----c272b6f22f67----------------------), hvor du blant annet finner enkle eksempler til de mest grunnleggende funksjonene og mulighetene API'et gir.

Tips: Under "Examples" i dokumentasjonen vi har linket til, scroll helt ned til "More", s친 finner du lenker til fungerende kodeeksempler i CodeSandbox!

Lest introduskjonsartikkelen? Da f친r det v칝re nok introduksjon, s친 la oss bare komme i gang!

## Emoji-guide (Bendik oversetter)

Du kommer til 친 se noen emojis i oppgavene. De betyr ca det her:

游끥Oppgave: Her er hva du skal gj칮re

游눠Tips: Litt ekstra info som kan v칝re greit 친 v칝re for 친 l칮se en oppgave

<details>
  <summary>游뚿L칮sningsforslag: Klikk meg! 游땕</summary>

Her finner du en komplett gjennomgang av hvordan du _kan_ l칮se oppgaven.

</details>

# Oppsett (Bendik oversetter)
1. Klon repoet: 
`git clone git@github.com:bekk/react-animation-workshop.git`

2. Sjekk ut branchen `master_workshop_edition`

3. Naviger til repo-mappen og kj칮r `npm install` etterfulgt av `npm run start` og appen vil kj칮re p친 `localhost:1234` i nettleseren.

# Oppgaver (Bendik oversetter)
Som du kanskje n친 ser har vi laget et enkelt kortspill som vil v칝re utgangspunktet for alt du skal gj칮re i denne workshopen, nemlig **krig**! Hvis du ikke husker reglene kan du sp칮rre en av de som holder workshopen, men det spiller ikke s친 stor rolle, fordi vi har implementert all spillmekanikken for deg. Det du skal fokusere p친 er all **animasjonen** som man kan tenke seg h칮rer til et slikt spill.

游눠Det er mye spillogikk implementert her og der i appen, og selv om vi har pr칮vd 친 skjule s친 mye vi kan vil du fortsatt m친tte forholde deg til filer og komponenter som inneholder en del logikk. Vi skal derimot pr칮ve 친 guide dere til de riktige stedene i appen der oppgavene skal l칮ses.

游눠Noen ganger kan det kanskje v칝re vanskelig 친 vite hvor man skal begynne for 친 l칮se en oppgave - en rask titt p친 l칮sningsforslaget kan is친fall v칝re lurt.

游눠Det er lov 친 leke seg med api'et, selv om du har l칮st akkurat det oppgaven ber deg om! Faktisk oppfordrer vi til det, da mange sannsynligvis vil kunne bli ferdig p친 godt under 2 timer hvis man bare g칮nner gjennom 游땒

## Oppgave 1: Drag (Bendik oversetter)
I denne oppgaven skal du klare 친 dra et kort fra en bunke til omr친det der det st친r *Dra kortet hit*.

La oss bryte ned oppgaven:
#### Oppgave 1a)
游끥Vi begynner med det f칮rste steget: gj칮r det mulig 친 klikke p친 et kort og dra det rundt, uten noen regler om hvor det skal lande.

游눠G친 til `components/Card/Card.jsx` og endre komponenten til 친 returnere en `<motion.div />` istedenfor en vanlig div.

<details>
  <summary>游뚿L칮sningsforslag</summary>

```js
  <motion.div
    ...
    drag
  >
    
```

</details>
<br/>

#### Oppgave 1b)

游끥Legg p친 constraints slik at kortet ikke flyter avg친rde. Ikke tenk p친 at det skal komme til riktig posisjon enda, dette kommer senere.

游눠`<motion.div>` har f칮lgende relevante props: `dragConstraints`, `dragElastic` og `onDragEnd`.

Vi har som sagt laget logikken, s친 dere skal f친 lov til 친 kose dere med animasjonen, s친 sett sistnevnte til:

```js
onDragEnd={(event) => {
    if (intersectsPlayArea(event)) {
        dispatch({ type: Action.PLAY });
    }
}}
```

Denne sjekker om kortet befinner seg innenfor det skraverte omr친det n친r det slippes, og vil endre staten til spillet samt flippe kortet n친r dette skjer.

<details>
  <summary>游뚿L칮sningsforslag</summary>
  Trikset for 친 f친 det her til 친 fungere i spillet er 친 sette constraints'ene til 0 i alle retninger. Framer sin `drag` har en elastisitet man kan styre med `dragElastic`-prop'en, som gj칮r at man kan f친 dratt kortet til riktig plassering selv om det ikke f친r lov til 친 "lande" noe annet sted enn der det startet.

```js
  <motion.div
    ...
    dragElastic={1}
    dragConstraints={{
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }}
    onDragEnd={(event) => {
        if (intersectsPlayArea(event)) {
            dispatch({ type: Action.PLAY });
        }
    }}
  >
    
```

</details>
<br/>

#### Oppgave 1c)

游끥Drag skal kun v칝re mulig hvis kortet er vendt ned. Fiks dette

游눠Man kan ha betinget drag slik: `drag={true}`

游눠`Card`-komponenten har en `state: CardState`

<details>
  <summary>游뚿L칮sningsforslag</summary>

```js
  <motion.div
    ...
    drag={state === CardState.CLOSED}
    ...
  >
    
```

</details>
<br/>


## Exercise 2: Animate
Let's continue animating!
The `animate` prop takes an object with values that tell the motion component how to animate itself. Whenever any of these values change, the motion component will smoothly animate itself accordingly. [Check out the official docs](https://www.framer.com/api/motion/animation/) for a complete overview of what `animate` can do. Examples of fields you can specify in the `animate` object are `rotation` and `scale`. For now you should probably focus on two fields you can use to position the component: `x` and `y`.

游끥Make the cards move to the right position when they're dragged to the shaded area.

游눠The `Card` component has a state variable, `position`, that updates for certain events in the course of the game. Use this to update the motion component.

<details>
  <summary>游뚿Solution</summary>
  All the game logic has already been implemented, which makes this exercise pretty straightforward. Simply assign the `position` variable to the motion components' `animate` prop. Here we've also assigned a rotation to the `animate` object for added realism, but this is optional.

```js
  <motion.div
    ...
    animate={{
        rotate: rotation,
        ...position
    }}
>
    <motion.div className={classNames('Card', isOpen ? 'open' : 'closed', suit)}>
        {isOpen && <CardFace value={value} />}
    </motion.div>
</motion.div>
```

</details>
<br/>

## Exercise 3: Add an animated menu
Every game needs a menu screen, and since this workshop is all about animations our menu is of course going to be an animated menu. We have prepared a simple menu component you can use which you'll find in `/components/Menu/Menu.jsx`. Before you start you need to add it to the app by rendering it at the top of the `App` component:

```js
  <div className="App">
      <div className="MenuContainer">
          <Menu />
      </div>
    <div className="Table">
      .
      .
      .
```

As you can see the menu is quite static at the moment, but we'll fix this in a moment.

#### Exercise 3a) (Stephen oversetter)

游끥Add a simple animation when the user clicks or hovers over the menu button. You should look in `Menu.jsx` for this exercise. 

游눠You'll find a list of available props to pass to the motion component here: https://www.framer.com/api/motion/component/. Take a closer look at `whileHover` and `whileTap`

<details>
  <summary>游뚿L칮sningsforslag</summary>
  
  Easy enough: Convert the  `button` elements to `motion.button` and pass the `whileHover` and `whileTap` props. 
  
```js
  const MenuButton = ({
    onClick,
    clicked
}) => {
    return (
        <motion.button
            ...
            whileHover={{scale: 1.1}}
            whileTap={{scale: 1.2}}
        >
            <div className="bar1"></div>
            <div className="bar2"></div>
            <div className="bar3"></div>
        </motion.button>
    )
}
```

</details>
<br/>

#### Oppgave 3b) (Stephen oversetter)

游끥Gj칮r noe tilsvarende med hvert menyelement

<details>
  <summary>游뚿L칮sningsforslag</summary>
  
```js
  <motion.li whileHover={{ scale: 1.5, translateX: 50 }} key={x.id}>
      <a href={x.url}>{x.name}</a>
  </motion.li>
```

</details>
<br/>

#### Oppgave 3c) (Stephen oversetter)

游끥Bruk "visuell state" med `variants` til 친 vise/skjule menyen n친r det klikkes p친 meny-ikonet.

游눠Les om `variants` her: https://www.framer.com/api/motion/animation/#variants. "Visuell state" kan settes i `animate`-propen til et element, og hvis elementet (eller barn-elementer) tar inn en `variants`-prop'en med et objekt som definerer ulike "views" for hver av statene vil det kunne animeres forskjellig basert p친 den visuelle staten.
游눠Se i `Menu` og `MenuArea` komponenten

<details>
  <summary>游뚿L칮sningsforslag</summary>
  
  F칮rst m친 vi endre `nav`-elementet til en `motion.nav` og sette "den visuelle staten" (*visual state* som doc'en kaller det) til `motion.nav`-elementet til enten `"open"` eller `"closed"` avhengig av om knappen er klikket eller ikke. Gj칮r vi det kan vi lage og sette `variants` i underelementene til `motion.nav`-elementet som inneholder disse to statene, som da kan rendres/animeres ulikt avhengig av den visuelle staten.
  
  ```js
  export const Menu = () => {
    const [isOpen, setIsOpen] = useState(false);

    return (
        <motion.nav className="Menu" initial="closed" animate={isOpen ? "open" : "closed"}>
            <MenuArea />
            <MenuButton onClick={setIsOpen} clicked={isOpen}/>
        </motion.nav>
    )
  }
  ```

Det er `MenuArea` vi vil at skal vises/skjules, og dette kan vi da gj칮re hvis vi endrer den til 친 rendre en `motion.div` som tar inn en `variants`-prop med et objekt, `variants_menuArea` hvor vi har definert ulik animasjon for de to visuelle statene, `"open"췂og `"closed"`:

  ```js
  const MenuArea = () => {
      const variants_menuArea = {
          open: {
              opacity: 1,
              x: 0,
          },
          closed: {
              opacity: 0,
              x: -200,
          }
      };

      return (
          <motion.div className="MenuArea" variants={variants_menuArea}>
              <MenuNavigation/>
          </motion.div>
      )
  }
  ```

Her har vi satt menyen til 친 fly inn og ut langs x-aksen, men her er det egentlig bare 친 leke seg!

  <details>
    <summary>游눠Vis/skjul menyen like a pro</summary>

    En kul effekt er 친 bruke `clipPath` som en variant for 친 skjule/vise menyen. Endre `variants_menuArea` til f칮lgende:

  ```js
  const variants_menuArea = {
        open: {
            clipPath: `circle(500px at 40px 40px)`,
            transition: {
                type: "spring",
                stiffness: 50,
            }
        },
        closed: {
            clipPath: "circle(30px at 40px 40px)",
            transition: {
                type: "spring",
                stiffness: 50,
            }
        }
    };
  ```

  </details>

</details>
<br/>

#### Oppgave 3d) (Stephen oversetter)

N친 skal vi legge p친 animasjoner p친 selve innholdet i menyen.

游끥F친 listen i menyen til 친 fly inn og ut fra toppen n친r menyen 친pnes/lukkes.

游눠Husk at barn av elementer som har en visuell state ogs친 kan bruke `variants` til 친 rendres/animeres avhengig av staten.
游눠Sett p친 en liten delay p친 kortet n친r det lukkes slik at innholdet rekker 친 animeres ferdig f칮r menyen forsvinner.
游눠Se `MenuNavigation`

<details>
  <summary>游뚿L칮sningsforslag</summary>
  
  Definer en `variants_menuList` i `MenuNavigation`: 
  
  ```js
  const variants_navItems = {
      open: {
          opacity: 1,
          y: 0
      }, 
      closed: {
          opacity: 0,
          y: -50
      }
  }
  ```
  
  Og legg den til p친 `motion.li`-elementene:

  ```js
  <motion.li variants={variants_navItems} key={x.id}>
      <a href={x.url}>{x.name}</a>
  </motion.li>
  ```
  
  For 친 f친 delay n친r kortet skjules, legg til f칮lgende i `closed`-objektet til `variants_menuArea`:
  
  ```js
  transition: {
      delay: 0.5
  }
  ```

</details>
<br/>

#### Oppgave 3e) (Stephen oversetter)

Vi kan la et forelder-element styre n친r animasjonene til barn-elementene blir satt i gang ved hjelp av `transition`-props som blant annet `staggerChildren`. For eksempel `staggerChildren: 1` vil utsette utf칮relsen av animasjonen til hvert barn-element med 1 sekund.

Dette kan vi bruke p친 liste-elementene i menyen v친r!

游끥Bruk `staggerChildren` til 친 f친 hvert listeelement i menyen til 친 fly inn hver for seg.

游눠`variants`-eksempelet i Framer-dokumentasjonen inneholder en meny som tilfeldigvis ligner litt p친 v친r, hvor det brukes `staggerChildren`...

<details>
  <summary>游뚿L칮sningsforslag</summary>
  
  Vi m친 definere et `variants`-objekt til `motion.ul`-elementet hvor vi setter `staggerChildren`. Det kan v칝re fint 친 sette p친 en `delayChildren` n친r vi 친pner menyen ogs친, slik at menyelementene ikke skal komme f칮r kortet vises helt. `delayChildren` vil utsette animasjonen til samtlige barn-elementer.
  
  ```js
  const variants_navList = {
      open: {
        transition: { staggerChildren: 0.1, delayChildren: 0.2 }
      },
      closed: {
        transition: { staggerChildren: 0.05}
      }
  };
  ```
  
  Og legg den til p친 `motion.ul`-elementet:

  ```js
  <motion.ul className="MenuNavigation" variants={variants_navList}>
  ```

</details>
<br/>

## Oppgave 4: Animere poengsummer (Stephen oversetter)

Siste oppgave blir 친 legge p친 animasjon p친 en feature som viser poengsummene til spillerne. Her er det mange muligheter, s친 dette blir en 친pen oppgave, men aller f칮rst: Rendre `<Score>`-komponenten i `App`, for eksempel rett etter menyen:

```js
<div className="MenuContainer">
    <Menu />
</div>
<div className="ScoreContainer">
    <Score playerScore={state.score.player} computerScore={state.score.computer}/>
</div>
```

游끥Bruk det du har l칝rt til n친 (eller bruk og l칝r noe helt nytt!) til 친 legge p친 animasjon p친 tallene hver gang poengsummen oppdateres.

游눠Et par relativt simple muligheter:
* Legge p친 rotasjon
* Skalere tallene iht. st칮rrelsesforholdet p친 poengsummene

## Ferdig f칮r tiden? (Stephen oversetter)

Da har vi et par forslag til hva du kan gj칮re n친:

游끥Gj칮r det mulig 친 kunne rearrangere elementene i menyen med drag and drop

游눠Det finnes et [eksempel i Framer-dokumentasjonen](https://codesandbox.io/s/framer-motion-drag-to-reorder-pkm1k) hvor akkurat dette gj칮res

<br/>

游끥Gj칮r om menyelementene til "Accordions" med noe random innhold

游눠[Accordion-eksempel i Framer docs'ene](https://codesandbox.io/s/framer-motion-accordion-qx958)

<br/>

游끥Vis en modal n친r man klikker p친 "Regler" i menyen som inneholder en lang og scrollbar tekst

游눠[Scroll-eksempel i Framer docs'ene](https://codesandbox.io/s/framer-motion-viewport-scroll-and-svg-path-animation-mwi35?fontsize=14&module=%2Fsrc%2FExample.tsx)
